<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DeseNet Documentation: hei::SharedBuffer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DeseNet Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hei</b></li><li class="navelem"><a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classhei_1_1SharedBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hei::SharedBuffer&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Buffer for shared data allowing multiple instances to use actually the same buffer and releases the buffer once the last user drops it. The buffer is <b>not resizeable!</b>  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sharedbuffer_8hpp_source.html">sharedbuffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a26150dcd3717460d78c8fda90ae151d6" id="r_a26150dcd3717460d78c8fda90ae151d6"><td class="memItemLeft" align="right" valign="top"><a id="a26150dcd3717460d78c8fda90ae151d6" name="a26150dcd3717460d78c8fda90ae151d6"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>valueType</b></td></tr>
<tr class="separator:a26150dcd3717460d78c8fda90ae151d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5048f73b659d27e62119bd9b3b9e6cb" id="r_ae5048f73b659d27e62119bd9b3b9e6cb"><td class="memItemLeft" align="right" valign="top"><a id="ae5048f73b659d27e62119bd9b3b9e6cb" name="ae5048f73b659d27e62119bd9b3b9e6cb"></a>
typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:ae5048f73b659d27e62119bd9b3b9e6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea926a07bc9a4eedef635486b90e558" id="r_aeea926a07bc9a4eedef635486b90e558"><td class="memItemLeft" align="right" valign="top"><a id="aeea926a07bc9a4eedef635486b90e558" name="aeea926a07bc9a4eedef635486b90e558"></a>
typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>constReference</b></td></tr>
<tr class="separator:aeea926a07bc9a4eedef635486b90e558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534ab214c9ebe39e89dc4c939d1a80eb" id="r_a534ab214c9ebe39e89dc4c939d1a80eb"><td class="memItemLeft" align="right" valign="top"><a id="a534ab214c9ebe39e89dc4c939d1a80eb" name="a534ab214c9ebe39e89dc4c939d1a80eb"></a>
typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>sizeType</b></td></tr>
<tr class="separator:a534ab214c9ebe39e89dc4c939d1a80eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc8c142f9b9b2d312968140a3ed3b42" id="r_abfc8c142f9b9b2d312968140a3ed3b42"><td class="memItemLeft" align="right" valign="top"><a id="abfc8c142f9b9b2d312968140a3ed3b42" name="abfc8c142f9b9b2d312968140a3ed3b42"></a>
typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>differenceType</b></td></tr>
<tr class="separator:abfc8c142f9b9b2d312968140a3ed3b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1affa6abe3f9dfe865ec64eb6e758510" id="r_a1affa6abe3f9dfe865ec64eb6e758510"><td class="memItemLeft" align="right" valign="top"><a id="a1affa6abe3f9dfe865ec64eb6e758510" name="a1affa6abe3f9dfe865ec64eb6e758510"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a1affa6abe3f9dfe865ec64eb6e758510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f12a83cc3271018816b92a6a2a38f1" id="r_a27f12a83cc3271018816b92a6a2a38f1"><td class="memItemLeft" align="right" valign="top"><a id="a27f12a83cc3271018816b92a6a2a38f1" name="a27f12a83cc3271018816b92a6a2a38f1"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><b>constPointer</b></td></tr>
<tr class="separator:a27f12a83cc3271018816b92a6a2a38f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21610ad09f74d44d7b9d4946c549f841" id="r_a21610ad09f74d44d7b9d4946c549f841"><td class="memItemLeft" align="right" valign="top"><a id="a21610ad09f74d44d7b9d4946c549f841" name="a21610ad09f74d44d7b9d4946c549f841"></a>
typedef pointer&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a21610ad09f74d44d7b9d4946c549f841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08d955d33a1297ca867e906de70d53c" id="r_af08d955d33a1297ca867e906de70d53c"><td class="memItemLeft" align="right" valign="top"><a id="af08d955d33a1297ca867e906de70d53c" name="af08d955d33a1297ca867e906de70d53c"></a>
typedef constPointer&#160;</td><td class="memItemRight" valign="bottom"><b>constIterator</b></td></tr>
<tr class="separator:af08d955d33a1297ca867e906de70d53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a415bb2a2dea096cc8de5e82cc1df45ca" id="r_a415bb2a2dea096cc8de5e82cc1df45ca"><td class="memItemLeft" align="right" valign="top"><a id="a415bb2a2dea096cc8de5e82cc1df45ca" name="a415bb2a2dea096cc8de5e82cc1df45ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SharedBuffer</b> ()</td></tr>
<tr class="memdesc:a415bb2a2dea096cc8de5e82cc1df45ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty and thus unusable shared buffer. <br /></td></tr>
<tr class="separator:a415bb2a2dea096cc8de5e82cc1df45ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212517a2df5f988ad8315e59069b6891" id="r_a212517a2df5f988ad8315e59069b6891"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a212517a2df5f988ad8315e59069b6891">SharedBuffer</a> (sizeType <a class="el" href="#a68c84acf27a3dac045135333bb6bd7de">length</a>)</td></tr>
<tr class="memdesc:a212517a2df5f988ad8315e59069b6891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a shared buffer with the given size on the heap.  <br /></td></tr>
<tr class="separator:a212517a2df5f988ad8315e59069b6891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2553862a3175d7891e96c1a3ebb5a791" id="r_a2553862a3175d7891e96c1a3ebb5a791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2553862a3175d7891e96c1a3ebb5a791">copy</a> () const</td></tr>
<tr class="memdesc:a2553862a3175d7891e96c1a3ebb5a791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of himself by copying the data to the new shared buffer.  <br /></td></tr>
<tr class="separator:a2553862a3175d7891e96c1a3ebb5a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece7bb3af3cbae8d10aa90b286f0ac07" id="r_aece7bb3af3cbae8d10aa90b286f0ac07"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aece7bb3af3cbae8d10aa90b286f0ac07">begin</a> ()</td></tr>
<tr class="memdesc:aece7bb3af3cbae8d10aa90b286f0ac07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <br /></td></tr>
<tr class="separator:aece7bb3af3cbae8d10aa90b286f0ac07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dbac102d69d990bf760a6e83fcc3f1" id="r_a61dbac102d69d990bf760a6e83fcc3f1"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61dbac102d69d990bf760a6e83fcc3f1">end</a> ()</td></tr>
<tr class="memdesc:a61dbac102d69d990bf760a6e83fcc3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <br /></td></tr>
<tr class="separator:a61dbac102d69d990bf760a6e83fcc3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bf62e6636b6eb15cbdada7ca458cb9" id="r_a31bf62e6636b6eb15cbdada7ca458cb9"><td class="memItemLeft" align="right" valign="top">constIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31bf62e6636b6eb15cbdada7ca458cb9">cbegin</a> () const</td></tr>
<tr class="memdesc:a31bf62e6636b6eb15cbdada7ca458cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <br /></td></tr>
<tr class="separator:a31bf62e6636b6eb15cbdada7ca458cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92191a0a51c320dd1fff6ad54d05bdc4" id="r_a92191a0a51c320dd1fff6ad54d05bdc4"><td class="memItemLeft" align="right" valign="top">constIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92191a0a51c320dd1fff6ad54d05bdc4">cend</a> () const</td></tr>
<tr class="memdesc:a92191a0a51c320dd1fff6ad54d05bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <br /></td></tr>
<tr class="separator:a92191a0a51c320dd1fff6ad54d05bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58061570968f5776227a25c509caf453" id="r_a58061570968f5776227a25c509caf453"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58061570968f5776227a25c509caf453">swap</a> (<a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a58061570968f5776227a25c509caf453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other. Does not cause iterators and references to associate with the other container.  <br /></td></tr>
<tr class="separator:a58061570968f5776227a25c509caf453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b805b053516b3c533e53ea2eba6b3c" id="r_a72b805b053516b3c533e53ea2eba6b3c"><td class="memItemLeft" align="right" valign="top">sizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72b805b053516b3c533e53ea2eba6b3c">size</a> () const</td></tr>
<tr class="memdesc:a72b805b053516b3c533e53ea2eba6b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. std::distance(<a class="el" href="#aece7bb3af3cbae8d10aa90b286f0ac07" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="#a61dbac102d69d990bf760a6e83fcc3f1" title="Returns an iterator to the element following the last element of the container.">end()</a>).  <br /></td></tr>
<tr class="separator:a72b805b053516b3c533e53ea2eba6b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c84acf27a3dac045135333bb6bd7de" id="r_a68c84acf27a3dac045135333bb6bd7de"><td class="memItemLeft" align="right" valign="top">sizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68c84acf27a3dac045135333bb6bd7de">length</a> () const</td></tr>
<tr class="memdesc:a68c84acf27a3dac045135333bb6bd7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. std::distance(<a class="el" href="#aece7bb3af3cbae8d10aa90b286f0ac07" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="#a61dbac102d69d990bf760a6e83fcc3f1" title="Returns an iterator to the element following the last element of the container.">end()</a>).  <br /></td></tr>
<tr class="separator:a68c84acf27a3dac045135333bb6bd7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9074cbda31ec14581a0720a947960005" id="r_a9074cbda31ec14581a0720a947960005"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9074cbda31ec14581a0720a947960005">empty</a> () const</td></tr>
<tr class="memdesc:a9074cbda31ec14581a0720a947960005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="#aece7bb3af3cbae8d10aa90b286f0ac07" title="Returns an iterator to the first element of the container.">begin()</a> == <a class="el" href="#a61dbac102d69d990bf760a6e83fcc3f1" title="Returns an iterator to the element following the last element of the container.">end()</a>.  <br /></td></tr>
<tr class="separator:a9074cbda31ec14581a0720a947960005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd34b6936bf7eaffaa0ad3234ab314f7" id="r_afd34b6936bf7eaffaa0ad3234ab314f7"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd34b6936bf7eaffaa0ad3234ab314f7">operator[]</a> (sizeType pos)</td></tr>
<tr class="memdesc:afd34b6936bf7eaffaa0ad3234ab314f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos. No bounds checking is performed.  <br /></td></tr>
<tr class="separator:afd34b6936bf7eaffaa0ad3234ab314f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cbd15457b207300ee4743c3c0d8467" id="r_ae6cbd15457b207300ee4743c3c0d8467"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6cbd15457b207300ee4743c3c0d8467">operator[]</a> (sizeType pos) const</td></tr>
<tr class="memdesc:ae6cbd15457b207300ee4743c3c0d8467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the element at specified location pos. No bounds checking is performed.  <br /></td></tr>
<tr class="separator:ae6cbd15457b207300ee4743c3c0d8467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f638c571b8f350d04af335b4d2d4ed0" id="r_a3f638c571b8f350d04af335b4d2d4ed0"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0">data</a> ()</td></tr>
<tr class="memdesc:a3f638c571b8f350d04af335b4d2d4ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="#a72b805b053516b3c533e53ea2eba6b3c" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>) is always a valid range, even if the container is empty.  <br /></td></tr>
<tr class="separator:a3f638c571b8f350d04af335b4d2d4ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e21616706cef083f481d9ca7e6c149" id="r_ac8e21616706cef083f481d9ca7e6c149"><td class="memItemLeft" align="right" valign="top">constPointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8e21616706cef083f481d9ca7e6c149">data</a> () const</td></tr>
<tr class="memdesc:ac8e21616706cef083f481d9ca7e6c149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="#a72b805b053516b3c533e53ea2eba6b3c" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>) is always a valid range, even if the container is empty.  <br /></td></tr>
<tr class="separator:ac8e21616706cef083f481d9ca7e6c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6dee80ae9d7904d8f9e3b5878e7e3c" id="r_afc6dee80ae9d7904d8f9e3b5878e7e3c"><td class="memItemLeft" align="right" valign="top">sizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc6dee80ae9d7904d8f9e3b5878e7e3c">use_count</a> () const</td></tr>
<tr class="memdesc:afc6dee80ae9d7904d8f9e3b5878e7e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of shared buffer instances that share ownership of the managed object, or ​0​ if the managed object has already been deleted, i.e. *this is empty.  <br /></td></tr>
<tr class="separator:afc6dee80ae9d7904d8f9e3b5878e7e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad20fd209ed31ac226a79a41cc5fd7a39" id="r_ad20fd209ed31ac226a79a41cc5fd7a39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad20fd209ed31ac226a79a41cc5fd7a39">proxy</a> (pointer <a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0">data</a>, sizeType <a class="el" href="#a68c84acf27a3dac045135333bb6bd7de">length</a>)</td></tr>
<tr class="memdesc:ad20fd209ed31ac226a79a41cc5fd7a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared buffer that represents the memory region passed by data and length.  <br /></td></tr>
<tr class="separator:ad20fd209ed31ac226a79a41cc5fd7a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8734194b256a493f7be2a32c38de06cb" id="r_a8734194b256a493f7be2a32c38de06cb"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8734194b256a493f7be2a32c38de06cb">proxy</a> (constPointer <a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0">data</a>, sizeType <a class="el" href="#a68c84acf27a3dac045135333bb6bd7de">length</a>)</td></tr>
<tr class="memdesc:a8734194b256a493f7be2a32c38de06cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a readonly shared buffer that represents the memory region passed by data and length.  <br /></td></tr>
<tr class="separator:a8734194b256a493f7be2a32c38de06cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec345db608340e84b2020116ca00fb0" id="r_a6ec345db608340e84b2020116ca00fb0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ec345db608340e84b2020116ca00fb0">copy</a> (constPointer <a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0">data</a>, sizeType <a class="el" href="#a68c84acf27a3dac045135333bb6bd7de">length</a>)</td></tr>
<tr class="memdesc:a6ec345db608340e84b2020116ca00fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared buffer by copying the data from the given memory location.  <br /></td></tr>
<tr class="separator:a6ec345db608340e84b2020116ca00fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class hei::SharedBuffer&lt; T &gt;</div><p>Buffer for shared data allowing multiple instances to use actually the same buffer and releases the buffer once the last user drops it. The buffer is <b>not resizeable!</b> </p>
<p>The buffer can be either proxy an existing buffer or a new buffer where the data is actually allocated on the heap can be created. If the buffer is allocated dynamically on the heap, the heap resources will be released once the last holder of the buffer deletes the buffer object automatically. The data is shared, so if someone makes changes on a buffer object, all other objects referring the same buffer do reflect these changes. If you want your own copy of a buffer, you have to call the <a class="el" href="#a6ec345db608340e84b2020116ca00fb0" title="Creates a shared buffer by copying the data from the given memory location.">copy()</a> method and use the <a class="el" href="classhei_1_1SharedBuffer.html" title="Buffer for shared data allowing multiple instances to use actually the same buffer and releases the b...">SharedBuffer</a> instance returned by that method. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a212517a2df5f988ad8315e59069b6891" name="a212517a2df5f988ad8315e59069b6891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212517a2df5f988ad8315e59069b6891">&#9670;&#160;</a></span>SharedBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::SharedBuffer </td>
          <td>(</td>
          <td class="paramtype">sizeType</td>          <td class="paramname"><span class="paramname"><em>length</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and returns a shared buffer with the given size on the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The number of elements the buffer has to be in size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aece7bb3af3cbae8d10aa90b286f0ac07" name="aece7bb3af3cbae8d10aa90b286f0ac07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece7bb3af3cbae8d10aa90b286f0ac07">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="#a61dbac102d69d990bf760a6e83fcc3f1" title="Returns an iterator to the element following the last element of the container.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the container. </dd></dl>

</div>
</div>
<a id="a31bf62e6636b6eb15cbdada7ca458cb9" name="a31bf62e6636b6eb15cbdada7ca458cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bf62e6636b6eb15cbdada7ca458cb9">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constIterator <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="#a61dbac102d69d990bf760a6e83fcc3f1" title="Returns an iterator to the element following the last element of the container.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the container. </dd></dl>

</div>
</div>
<a id="a92191a0a51c320dd1fff6ad54d05bdc4" name="a92191a0a51c320dd1fff6ad54d05bdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92191a0a51c320dd1fff6ad54d05bdc4">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constIterator <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element of the container. </dd></dl>

</div>
</div>
<a id="a2553862a3175d7891e96c1a3ebb5a791" name="a2553862a3175d7891e96c1a3ebb5a791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2553862a3175d7891e96c1a3ebb5a791">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a> <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of himself by copying the data to the new shared buffer. </p>
<p>Note that the actual buffer needed to hold the data is allocated on the heap.</p>
<dl class="section return"><dt>Returns</dt><dd>A new shared buffer as a copy. </dd></dl>

</div>
</div>
<a id="a6ec345db608340e84b2020116ca00fb0" name="a6ec345db608340e84b2020116ca00fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec345db608340e84b2020116ca00fb0">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a> <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">constPointer</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeType</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a shared buffer by copying the data from the given memory location. </p>
<p>Note that the actual buffer needed to hold the data is allocated on the heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the start of the readonly memory region to copy into the shared buffer. </td></tr>
    <tr><td class="paramname">length</td><td>The actual size of the memory region to copy into the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f638c571b8f350d04af335b4d2d4ed0" name="a3f638c571b8f350d04af335b4d2d4ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f638c571b8f350d04af335b4d2d4ed0">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="#a72b805b053516b3c533e53ea2eba6b3c" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>) is always a valid range, even if the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, returns &amp;front(). </dd></dl>

</div>
</div>
<a id="ac8e21616706cef083f481d9ca7e6c149" name="ac8e21616706cef083f481d9ca7e6c149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e21616706cef083f481d9ca7e6c149">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constPointer <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="#a3f638c571b8f350d04af335b4d2d4ed0" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="#a72b805b053516b3c533e53ea2eba6b3c" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a>) is always a valid range, even if the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, returns &amp;front(). </dd></dl>

</div>
</div>
<a id="a9074cbda31ec14581a0720a947960005" name="a9074cbda31ec14581a0720a947960005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9074cbda31ec14581a0720a947960005">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <a class="el" href="#aece7bb3af3cbae8d10aa90b286f0ac07" title="Returns an iterator to the first element of the container.">begin()</a> == <a class="el" href="#a61dbac102d69d990bf760a6e83fcc3f1" title="Returns an iterator to the element following the last element of the container.">end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a61dbac102d69d990bf760a6e83fcc3f1" name="a61dbac102d69d990bf760a6e83fcc3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dbac102d69d990bf760a6e83fcc3f1">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element of the container. </dd></dl>

</div>
</div>
<a id="a68c84acf27a3dac045135333bb6bd7de" name="a68c84acf27a3dac045135333bb6bd7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c84acf27a3dac045135333bb6bd7de">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sizeType <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. std::distance(<a class="el" href="#aece7bb3af3cbae8d10aa90b286f0ac07" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="#a61dbac102d69d990bf760a6e83fcc3f1" title="Returns an iterator to the element following the last element of the container.">end()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a id="afd34b6936bf7eaffaa0ad3234ab314f7" name="afd34b6936bf7eaffaa0ad3234ab314f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd34b6936bf7eaffaa0ad3234ab314f7">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">sizeType</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a id="ae6cbd15457b207300ee4743c3c0d8467" name="ae6cbd15457b207300ee4743c3c0d8467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cbd15457b207300ee4743c3c0d8467">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">sizeType</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the element at specified location pos. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position of the element to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a id="a8734194b256a493f7be2a32c38de06cb" name="a8734194b256a493f7be2a32c38de06cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8734194b256a493f7be2a32c38de06cb">&#9670;&#160;</a></span>proxy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a> <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::proxy </td>
          <td>(</td>
          <td class="paramtype">constPointer</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeType</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a readonly shared buffer that represents the memory region passed by data and length. </p>
<p>Note that it is important to understand that as long as there are instances of this buffer left, the memory at data can be read, so if you are passing a shared pointer to another method, check that the use count of the buffer is 1 after the method was called in order to avoid dangling shared buffers still pointing to the memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the start of the readonly memory region to represent by the shared buffer. </td></tr>
    <tr><td class="paramname">length</td><td>The actual number of elements inside the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad20fd209ed31ac226a79a41cc5fd7a39" name="ad20fd209ed31ac226a79a41cc5fd7a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20fd209ed31ac226a79a41cc5fd7a39">&#9670;&#160;</a></span>proxy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a> <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::proxy </td>
          <td>(</td>
          <td class="paramtype">pointer</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sizeType</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a shared buffer that represents the memory region passed by data and length. </p>
<p>Note that it is important to understand that as long as there are instances of this buffer left, the memory at data can be modified, so if you are passing a shared pointer to another method, check that the use count of the buffer is 1 after the method was called in order to avoid dangling shared buffers still pointing to the memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the start of the memory region to represent by the shared buffer. </td></tr>
    <tr><td class="paramname">length</td><td>The actual number of elements inside the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b805b053516b3c533e53ea2eba6b3c" name="a72b805b053516b3c533e53ea2eba6b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b805b053516b3c533e53ea2eba6b3c">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sizeType <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. std::distance(<a class="el" href="#aece7bb3af3cbae8d10aa90b286f0ac07" title="Returns an iterator to the first element of the container.">begin()</a>, <a class="el" href="#a61dbac102d69d990bf760a6e83fcc3f1" title="Returns an iterator to the element following the last element of the container.">end()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a id="a58061570968f5776227a25c509caf453" name="a58061570968f5776227a25c509caf453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58061570968f5776227a25c509caf453">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhei_1_1SharedBuffer.html">SharedBuffer</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. Does not cause iterators and references to associate with the other container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Container to exchange the contents with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc6dee80ae9d7904d8f9e3b5878e7e3c" name="afc6dee80ae9d7904d8f9e3b5878e7e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6dee80ae9d7904d8f9e3b5878e7e3c">&#9670;&#160;</a></span>use_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sizeType <a class="el" href="classhei_1_1SharedBuffer.html">hei::SharedBuffer</a>&lt; T &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of shared buffer instances that share ownership of the managed object, or ​0​ if the managed object has already been deleted, i.e. *this is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of shared buffer instances sharing the ownership of the managed buffer. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/thomas.sterren.VS-W11521/Desktop/03-release/work/desenet-sensor/src/common/mdw/containers/<a class="el" href="sharedbuffer_8hpp_source.html">sharedbuffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 29 2025 10:56:38 for DeseNet Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
